{"version":3,"file":"memories-components_top-matter_MapSplitMatter_vue.js?v=33992dc7ceb1683e4312","mappings":"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","sources":["webpack:///memories/src/components/top-matter/MapSplitMatter.vue?vue&type=style&index=0&id=58f64320&prod&lang=scss&scoped=true","webpack:///memories/src/components/top-matter/MapSplitMatter.vue?vue&type=style&index=1&id=58f64320&prod&lang=scss","webpack:///memories/src/components/top-matter/MapSplitMatter.vue?vue&type=template&id=58f64320&scoped=true","webpack:///memories/components/top-matter/MapSplitMatter.vue","webpack:///memories/src/components/top-matter/MapSplitMatter.vue?vue&type=script&lang=ts","webpack://memories/./components/top-matter/MapSplitMatter.vue?9e8b","webpack://memories/./components/top-matter/MapSplitMatter.vue?6832","webpack:///memories/src/components/top-matter/MapSplitMatter.vue"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.map-matter[data-v-58f64320]{height:100%;width:100%}.map[data-v-58f64320]{height:100%;width:100%;margin:0;z-index:0;background-color:var(--color-background-dark)}.map[data-v-58f64320] .leaflet-control-attribution{background-color:var(--color-background-dark);color:var(--color-text-light)}.map[data-v-58f64320] .leaflet-bar a{background-color:var(--color-main-background);color:var(--color-main-text)}.map[data-v-58f64320] .leaflet-bar a.leaflet-disabled{opacity:.6}.preview[data-v-58f64320]{width:48px;height:48px;background-color:rgba(0,0,0,.3);border-radius:5px;position:relative;box-shadow:0 0 3px rgba(0,0,0,.2)}.preview[data-v-58f64320]:hover{box-shadow:0 0 3px var(--color-primary)}.preview img[data-v-58f64320]{width:100%;height:100%;object-fit:cover;border-radius:5px;cursor:pointer}.preview .count[data-v-58f64320]{background-color:var(--color-primary);color:var(--color-primary-text);padding:0 4px;border-radius:5px;font-size:.8em}`, \"\",{\"version\":3,\"sources\":[\"webpack://./components/top-matter/MapSplitMatter.vue\"],\"names\":[],\"mappings\":\"AACA,6BACE,WAAA,CACA,UAAA,CAGF,sBACE,WAAA,CACA,UAAA,CACA,QAAA,CACA,SAAA,CACA,6CAAA,CAEA,mDACE,6CAAA,CACA,6BAAA,CAGF,qCACE,6CAAA,CACA,4BAAA,CAEA,sDACE,UAAA,CAKN,0BACE,UAAA,CACA,WAAA,CACA,+BAAA,CACA,iBAAA,CACA,iBAAA,CACA,iCAAA,CAEA,gCACE,uCAAA,CAGF,8BACE,UAAA,CACA,WAAA,CACA,gBAAA,CACA,iBAAA,CACA,cAAA,CAGF,iCACE,qCAAA,CACA,+BAAA,CACA,aAAA,CACA,iBAAA,CACA,cAAA\",\"sourcesContent\":[\"\\n.map-matter {\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n.map {\\n  height: 100%;\\n  width: 100%;\\n  margin: 0;\\n  z-index: 0;\\n  background-color: var(--color-background-dark);\\n\\n  :deep .leaflet-control-attribution {\\n    background-color: var(--color-background-dark);\\n    color: var(--color-text-light);\\n  }\\n\\n  :deep .leaflet-bar a {\\n    background-color: var(--color-main-background);\\n    color: var(--color-main-text);\\n\\n    &.leaflet-disabled {\\n      opacity: 0.6;\\n    }\\n  }\\n}\\n\\n.preview {\\n  width: 48px;\\n  height: 48px;\\n  background-color: rgba(0, 0, 0, 0.3);\\n  border-radius: 5px;\\n  position: relative;\\n  box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);\\n\\n  &:hover {\\n    box-shadow: 0 0 3px var(--color-primary);\\n  }\\n\\n  img {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    border-radius: 5px;\\n    cursor: pointer;\\n  }\\n\\n  .count {\\n    background-color: var(--color-primary);\\n    color: var(--color-primary-text);\\n    padding: 0 4px;\\n    border-radius: 5px;\\n    font-size: 0.8em;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.anim-markers .leaflet-marker-icon{transition:transform .3s ease}.leaflet-marker-icon.dummy{z-index:-100000 !important}.leaflet-marker-icon:hover{z-index:100000 !important}`, \"\",{\"version\":3,\"sources\":[\"webpack://./components/top-matter/MapSplitMatter.vue\"],\"names\":[],\"mappings\":\"AAEE,mCACE,6BAAA,CAGF,2BACE,0BAAA,CAGF,2BACE,yBAAA\",\"sourcesContent\":[\"\\n.leaflet-marker-icon {\\n  .anim-markers & {\\n    transition: transform 0.3s ease;\\n  }\\n\\n  &.dummy {\\n    z-index: -100000 !important;\\n  }\\n\\n  &:hover {\\n    z-index: 100000 !important;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('div',{class:{\n    'map-matter': true,\n    'anim-markers': _vm.animMarkers,\n  }},[_c('LMap',{ref:\"map\",staticClass:\"map\",attrs:{\"crossOrigin\":true,\"zoom\":_vm.zoom,\"minZoom\":2,\"options\":_vm.mapOptions},on:{\"moveend\":_vm.refreshDebounced,\"zoomend\":_vm.refreshDebounced}},[_c('LTileLayer',{attrs:{\"url\":_vm.tileurl,\"attribution\":_vm.attribution,\"noWrap\":true}}),_vm._v(\" \"),_vm._l((_vm.clusters),function(cluster){return _c('LMarker',{key:cluster.id,attrs:{\"lat-lng\":cluster.center},on:{\"click\":function($event){return _vm.zoomTo(cluster)}}},[_c('LIcon',{attrs:{\"icon-anchor\":[24, 24],\"className\":_vm.clusterIconClass(cluster)}},[_c('div',{staticClass:\"preview\"},[(cluster.count > 1)?_c('div',{staticClass:\"count top-left\"},[_vm._v(\"\\n            \"+_vm._s(cluster.count)+\"\\n          \")]):_vm._e(),_vm._v(\" \"),_vm._o(_c('XImg',{class:['thumb-important', `memories-thumb-${cluster.preview.fileid}`],attrs:{\"src\":_vm.clusterPreviewUrl(cluster)}}),0,cluster.id)],1)])],1)})],2)],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div\n    :class=\"{\n      'map-matter': true,\n      'anim-markers': animMarkers,\n    }\"\n  >\n    <LMap\n      class=\"map\"\n      ref=\"map\"\n      :crossOrigin=\"true\"\n      :zoom=\"zoom\"\n      :minZoom=\"2\"\n      @moveend=\"refreshDebounced\"\n      @zoomend=\"refreshDebounced\"\n      :options=\"mapOptions\"\n    >\n      <LTileLayer :url=\"tileurl\" :attribution=\"attribution\" :noWrap=\"true\" />\n      <LMarker v-for=\"cluster of clusters\" :key=\"cluster.id\" :lat-lng=\"cluster.center\" @click=\"zoomTo(cluster)\">\n        <LIcon :icon-anchor=\"[24, 24]\" :className=\"clusterIconClass(cluster)\">\n          <div class=\"preview\">\n            <div class=\"count top-left\" v-if=\"cluster.count > 1\">\n              {{ cluster.count }}\n            </div>\n            <XImg\n              v-once\n              :src=\"clusterPreviewUrl(cluster)\"\n              :class=\"['thumb-important', `memories-thumb-${cluster.preview.fileid}`]\"\n            />\n          </div>\n        </LIcon>\n      </LMarker>\n    </LMap>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport { LMap, LTileLayer, LMarker, LPopup, LIcon } from 'vue2-leaflet';\nimport { latLngBounds, Icon } from 'leaflet';\n\nimport axios from '@nextcloud/axios';\n\nimport { API } from '@services/API';\nimport * as utils from '@services/utils';\n\nimport type { IPhoto } from '@typings';\n\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet-edgebuffer';\n\nconst OSM_TILE_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\nconst OSM_ATTRIBUTION = '&copy; <a target=\"_blank\" href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors';\n\n// CSS transition time for zooming in/out cluster animation\nconst CLUSTER_TRANSITION_TIME = 300;\n\ntype IMarkerCluster = {\n  id: number;\n  center: [number, number];\n  count: number;\n  preview: IPhoto;\n  dummy?: boolean;\n};\n\ndelete (<any>Icon.Default.prototype)._getIconUrl;\n\nIcon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\nexport default defineComponent({\n  name: 'MapSplitMatter',\n  components: {\n    LMap,\n    LTileLayer,\n    LMarker,\n    LPopup,\n    LIcon,\n  },\n\n  data: () => ({\n    zoom: 2,\n    oldZoom: 2,\n    mapOptions: {\n      maxBounds: latLngBounds([-90, -180], [90, 180]),\n      maxBoundsViscosity: 0.9,\n    },\n    clusters: [] as IMarkerCluster[],\n    animMarkers: false,\n  }),\n\n  mounted() {\n    // Make sure the zoom control doesn't overlap with the navbar\n    this.refs.map.mapObject.zoomControl.setPosition('topright');\n\n    // Initialize\n    this.initialize();\n  },\n\n  created() {\n    utils.bus.on('memories:window:resize', this.handleContainerResize);\n  },\n\n  beforeDestroy() {\n    utils.bus.off('memories:window:resize', this.handleContainerResize);\n  },\n\n  computed: {\n    refs() {\n      return this.$refs as {\n        map: LMap;\n      };\n    },\n\n    tileurl() {\n      return OSM_TILE_URL;\n    },\n\n    attribution() {\n      return OSM_ATTRIBUTION;\n    },\n  },\n\n  watch: {\n    $route(curr, old) {\n      if (curr.query.b === old.query.b && curr.query.z === old.query.z) return;\n      this.initialize(true);\n    },\n  },\n\n  methods: {\n    /**\n     * Get initial coordinates for display and set them.\n     * Then fetch clusters.\n     */\n    async initialize(reinit: boolean = false) {\n      // Check if we have bounds and zoom in query\n      if (this.$route.query.b && this.$route.query.z) {\n        if (!reinit) {\n          this.setBoundsFromQuery();\n        }\n        return await this.fetchClusters();\n      }\n\n      // Otherwise, get location from server\n      try {\n        const init = await axios.get<{\n          pos?: {\n            lat?: number;\n            lon?: number;\n          };\n        }>(API.MAP_INIT());\n\n        // Init data contains position information\n        const map = this.refs.map;\n        const pos = init?.data?.pos;\n        if (!pos?.lat || !pos?.lon) {\n          throw new Error('No position data');\n        }\n\n        // This will trigger route change -> fetchClusters\n        map.mapObject.setView([pos.lat, pos.lon], 11);\n      } catch (e) {\n        // We will initialize clusters anyway\n      } finally {\n        this.refresh();\n      }\n    },\n\n    async refreshDebounced() {\n      utils.setRenewingTimeout(this, 'refreshTimer', this.refresh, 250);\n    },\n\n    async refresh() {\n      const map = this.refs.map;\n      if (!map || !map.mapObject) return;\n\n      // Get boundaries of the map\n      const boundary = map.mapObject.getBounds();\n      let minLat = boundary.getSouth();\n      let maxLat = boundary.getNorth();\n      let minLon = boundary.getWest();\n      let maxLon = boundary.getEast();\n\n      // Set query parameters to route if required\n      const bounds = this.boundsToStr({ minLat, maxLat, minLon, maxLon });\n\n      // Zoom level\n      this.zoom = Math.round(map.mapObject.getZoom());\n\n      // Construct query\n      const query = {\n        b: bounds,\n        z: this.zoom.toString(),\n      };\n\n      // If the query parameters are the same, don't do anything\n      if (this.$route.query.b === query.b && this.$route.query.z === query.z) {\n        return;\n      }\n\n      // Add new query keeping old hash for viewer\n      this.$router.replace({\n        query: query,\n        hash: this.$route.hash,\n      });\n    },\n\n    async fetchClusters() {\n      const oldZoom = this.oldZoom;\n      const qbounds = this.$route.query.b;\n      const zoom = this.$route.query.z as string;\n      const paramsChanged = () => this.$route.query.b !== qbounds || this.$route.query.z !== zoom;\n\n      let { minLat, maxLat, minLon, maxLon } = this.boundsFromQuery();\n\n      // Extend bounds by 25% beyond the map\n      const latDiff = Math.abs(maxLat - minLat);\n      const lonDiff = Math.abs(maxLon - minLon);\n      minLat -= latDiff * 0.25;\n      maxLat += latDiff * 0.25;\n      minLon -= lonDiff * 0.25;\n      maxLon += lonDiff * 0.25;\n\n      // Get bounds with expanded margins\n      const bounds = this.boundsToStr({ minLat, maxLat, minLon, maxLon });\n\n      // Make API call\n      const url = API.Q(API.MAP_CLUSTERS(), { bounds, zoom });\n\n      // Params have changed, quit\n      const res = await axios.get(url);\n      if (paramsChanged()) return;\n\n      // Mark currently loaded zoom level\n      this.oldZoom = this.zoom;\n\n      if (this.zoom > oldZoom) {\n        this.setClustersZoomIn(res.data, oldZoom);\n      } else if (this.zoom < oldZoom) {\n        this.setClustersZoomOut(res.data);\n      } else {\n        this.clusters = res.data;\n      }\n\n      // Animate markers\n      this.animateMarkers();\n    },\n\n    boundsFromQuery() {\n      const bounds = (this.$route.query.b as string).split(',');\n      return {\n        minLat: parseFloat(bounds[0]),\n        maxLat: parseFloat(bounds[1]),\n        minLon: parseFloat(bounds[2]),\n        maxLon: parseFloat(bounds[3]),\n      };\n    },\n\n    boundsToStr({\n      minLat,\n      maxLat,\n      minLon,\n      maxLon,\n    }: {\n      minLat: number;\n      maxLat: number;\n      minLon: number;\n      maxLon: number;\n    }) {\n      const s = (x: number) => x.toFixed(6);\n      return `${s(minLat)},${s(maxLat)},${s(minLon)},${s(maxLon)}`;\n    },\n\n    setBoundsFromQuery() {\n      const map = this.refs.map;\n      const { minLat, maxLat, minLon, maxLon } = this.boundsFromQuery();\n      map.mapObject.fitBounds([\n        [minLat, minLon],\n        [maxLat, maxLon],\n      ]);\n    },\n\n    clusterPreviewUrl(cluster: IMarkerCluster) {\n      return utils.getPreviewUrl({\n        photo: cluster.preview,\n        msize: 256,\n      });\n    },\n\n    clusterIconClass(cluster: IMarkerCluster) {\n      return cluster.dummy ? 'dummy' : '';\n    },\n\n    zoomTo(cluster: IMarkerCluster) {\n      // At high zoom levels, open the photo\n      if (this.zoom >= 12 && cluster.preview) {\n        cluster.preview.key = cluster.preview.fileid.toString();\n        _m.viewer.open(cluster.preview);\n        return;\n      }\n\n      // Zoom in\n      const map = this.refs.map;\n      const factor = globalThis.innerWidth >= 768 ? 2 : 1;\n      const zoom = map.mapObject.getZoom() + factor;\n      map.mapObject.setView(cluster.center, zoom, { animate: true });\n    },\n\n    getGridKey(center: [number, number], zoom: number) {\n      // Calcluate grid length\n      const clusterDensity = 1;\n      const oldGridLen = 180.0 / (2 ** zoom * clusterDensity);\n\n      // Get map key\n      const latGid = Math.floor(center[0] / oldGridLen);\n      const lonGid = Math.floor(center[1] / oldGridLen);\n      return `${latGid}-${lonGid}`;\n    },\n\n    getGridMap(clusters: IMarkerCluster[], zoom: number) {\n      const gridMap = new Map<string, IMarkerCluster>();\n      for (const cluster of clusters) {\n        const key = this.getGridKey(cluster.center, zoom);\n        gridMap.set(key, cluster);\n      }\n      return gridMap;\n    },\n\n    async setClustersZoomIn(clusters: IMarkerCluster[], oldZoom: number) {\n      // Create GID-map for old clusters\n      const oldClusters = this.getGridMap(this.clusters, oldZoom);\n\n      // Dummy clusters to animate markers\n      const dummyClusters: IMarkerCluster[] = [];\n\n      // Iterate new clusters\n      for (const cluster of clusters) {\n        // Check if cluster already exists\n        const key = this.getGridKey(cluster.center, oldZoom);\n        const oldCluster = oldClusters.get(key);\n        if (oldCluster) {\n          // Copy cluster and set location to old cluster\n          dummyClusters.push({\n            ...cluster,\n            center: oldCluster.center,\n          });\n        } else {\n          // Just show it\n          dummyClusters.push(cluster);\n        }\n      }\n\n      // Set clusters\n      this.clusters = dummyClusters;\n      await this.$nextTick();\n      await new Promise((r) => setTimeout(r, 0));\n      this.clusters = clusters;\n    },\n\n    async setClustersZoomOut(clusters: IMarkerCluster[]) {\n      // Get GID-map for new clusters\n      const newClustersGid = this.getGridMap(clusters, this.zoom);\n\n      // Get ID-map for new clusters\n      const newClustersId = new Map<number, IMarkerCluster>();\n      for (const cluster of clusters) {\n        newClustersId.set(cluster.id, cluster);\n      }\n\n      // Dummy clusters to animate markers\n      const dummyClusters: IMarkerCluster[] = [...clusters];\n\n      // Iterate old clusters\n      for (const oldCluster of this.clusters) {\n        // Process only clusters that are not in the new clusters\n        const newCluster = newClustersId.get(oldCluster.id);\n        if (!newCluster) {\n          // Get the new cluster at the same GID\n          const key = this.getGridKey(oldCluster.center, this.zoom);\n          const newCluster = newClustersGid.get(key);\n          if (newCluster) {\n            // No need to copy; it is gone anyway\n            oldCluster.center = newCluster.center;\n            oldCluster.dummy = true;\n            dummyClusters.push(oldCluster);\n          }\n        }\n      }\n\n      // Set clusters\n      this.clusters = dummyClusters;\n      await new Promise((r) => setTimeout(r, CLUSTER_TRANSITION_TIME)); // wait for animation\n      this.clusters = clusters;\n    },\n\n    async animateMarkers() {\n      this.animMarkers = true;\n      await new Promise((r) => setTimeout(r, CLUSTER_TRANSITION_TIME)); // wait for animation\n      this.animMarkers = false;\n    },\n\n    handleContainerResize() {\n      this.refs.map?.mapObject?.invalidateSize(true);\n    },\n  },\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.map-matter {\n  height: 100%;\n  width: 100%;\n}\n\n.map {\n  height: 100%;\n  width: 100%;\n  margin: 0;\n  z-index: 0;\n  background-color: var(--color-background-dark);\n\n  :deep .leaflet-control-attribution {\n    background-color: var(--color-background-dark);\n    color: var(--color-text-light);\n  }\n\n  :deep .leaflet-bar a {\n    background-color: var(--color-main-background);\n    color: var(--color-main-text);\n\n    &.leaflet-disabled {\n      opacity: 0.6;\n    }\n  }\n}\n\n.preview {\n  width: 48px;\n  height: 48px;\n  background-color: rgba(0, 0, 0, 0.3);\n  border-radius: 5px;\n  position: relative;\n  box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);\n\n  &:hover {\n    box-shadow: 0 0 3px var(--color-primary);\n  }\n\n  img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    border-radius: 5px;\n    cursor: pointer;\n  }\n\n  .count {\n    background-color: var(--color-primary);\n    color: var(--color-primary-text);\n    padding: 0 4px;\n    border-radius: 5px;\n    font-size: 0.8em;\n  }\n}\n</style>\n\n<style lang=\"scss\">\n.leaflet-marker-icon {\n  .anim-markers & {\n    transition: transform 0.3s ease;\n  }\n\n  &.dummy {\n    z-index: -100000 !important;\n  }\n\n  &:hover {\n    z-index: 100000 !important;\n  }\n}\n</style>\n","import mod from \"-!../../../node_modules/ts-loader/index.js??clonedRuleSet-4.use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=script&lang=ts\"; export default mod; export * from \"-!../../../node_modules/ts-loader/index.js??clonedRuleSet-4.use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=script&lang=ts\"","\n      import API from \"!../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=style&index=0&id=58f64320&prod&lang=scss&scoped=true\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=style&index=0&id=58f64320&prod&lang=scss&scoped=true\";\n       export default content && content.locals ? content.locals : undefined;\n","\n      import API from \"!../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=style&index=1&id=58f64320&prod&lang=scss\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MapSplitMatter.vue?vue&type=style&index=1&id=58f64320&prod&lang=scss\";\n       export default content && content.locals ? content.locals : undefined;\n","import { render, staticRenderFns } from \"./MapSplitMatter.vue?vue&type=template&id=58f64320&scoped=true\"\nimport script from \"./MapSplitMatter.vue?vue&type=script&lang=ts\"\nexport * from \"./MapSplitMatter.vue?vue&type=script&lang=ts\"\nimport style0 from \"./MapSplitMatter.vue?vue&type=style&index=0&id=58f64320&prod&lang=scss&scoped=true\"\nimport style1 from \"./MapSplitMatter.vue?vue&type=style&index=1&id=58f64320&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"58f64320\",\n  null\n  \n)\n\nexport default component.exports"],"names":["___CSS_LOADER_EXPORT___","push","module","id","Icon","options","styleTagTransform","setAttributes","insert","domAPI","insertStyleElement","locals","_vm","this","_c","_self","_setupProxy","class","animMarkers","ref","staticClass","attrs","zoom","mapOptions","on","refreshDebounced","tileurl","attribution","_v","_l","cluster","key","center","$event","zoomTo","clusterIconClass","count","_s","_e","_o","preview","fileid","clusterPreviewUrl"],"sourceRoot":""}