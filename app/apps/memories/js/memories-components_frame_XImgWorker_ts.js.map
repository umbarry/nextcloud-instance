{"version":3,"file":"memories-components_frame_XImgWorker_ts.js?v=929144e247a9aeaafe48","mappings":"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","sources":["webpack:///memories/src/components/frame/XImgWorker.ts"],"sourcesContent":["import { CacheExpiration } from 'workbox-expiration';\nimport { exportWorker } from 'webworker-typed';\n\ndeclare var self: ServiceWorkerGlobalScope;\n\ninterface BlobCallback {\n  resolve: (blob: Blob) => void;\n  reject: (err: Error) => void;\n}\n\n// Queue of requests to fetch preview images\ninterface FetchPreviewObject {\n  origUrl: string;\n  url: URL;\n  fileid: number;\n  reqid: number;\n  done?: boolean;\n}\nlet fetchPreviewQueue: FetchPreviewObject[] = [];\n\n// Pending requests\nconst pendingUrls = new Map<string, BlobCallback[]>();\n\n// Cache for preview images\nconst cacheName = 'memories-images';\nlet imageCache: Cache | undefined;\n(async function openCache() {\n  try {\n    imageCache = await self.caches?.open(cacheName);\n  } catch {\n    console.warn('Failed to open cache in worker');\n  }\n})();\n\n// Expiration for cache\nconst expirationManager = new CacheExpiration(cacheName, {\n  maxAgeSeconds: 3600 * 24 * 7, // days\n  maxEntries: 20000, // 20k images\n});\n\n// Start fetching with multipreview\nlet fetchPreviewTimer: number;\n\n/** Flushes the queue of preview image requests */\nasync function flushPreviewQueue() {\n  // Clear timer\n  if (fetchPreviewTimer) {\n    self.clearTimeout(fetchPreviewTimer);\n    fetchPreviewTimer = 0;\n  }\n\n  // Check if queue is empty\n  if (fetchPreviewQueue.length === 0) return;\n\n  // Copy queue and clear\n  const fetchPreviewQueueCopy = fetchPreviewQueue;\n  fetchPreviewQueue = [];\n\n  // Respond to URL\n  const resolve = async (url: string, res: Response, blob?: Blob) => {\n    // Response body can be read only once\n    const clone = res.clone();\n\n    // In case this throws, let the outer catch handle it\n    // This is because we want to ignore this response in case\n    // it came from a multipreview, so that we can try fetching\n    // the single image instead\n    blob ??= await res.blob();\n    pendingUrls.get(url)?.forEach((cb) => cb?.resolve?.(blob!));\n    pendingUrls.delete(url);\n\n    // Cache response\n    cacheResponse(url, clone);\n  };\n\n  // Throw error on URL\n  const reject = (url: string, e: any): void => {\n    pendingUrls.get(url)?.forEach((cb) => cb?.reject?.(e));\n    pendingUrls.delete(url);\n  };\n\n  // Make a single-file request\n  const fetchOneSafe = async (p: FetchPreviewObject) => {\n    try {\n      await resolve(p.origUrl, await fetchOneImage(p.origUrl));\n    } catch (e) {\n      reject(p.origUrl, e);\n    }\n  };\n\n  // Check if only one request, not worth a multipreview\n  if (fetchPreviewQueueCopy.length === 1) {\n    await fetchOneSafe(fetchPreviewQueueCopy[0]);\n    return;\n  }\n\n  // Create aggregated request body\n  const files = fetchPreviewQueueCopy.map((p) => ({\n    fileid: p.fileid,\n    x: Number(p.url.searchParams.get('x')),\n    y: Number(p.url.searchParams.get('y')),\n    a: p.url.searchParams.get('a'),\n    reqid: p.reqid,\n  }));\n\n  try {\n    // Fetch multipreview\n    const res = await fetchMultipreview(files);\n    if (res.status !== 200 || !res.body) throw new Error('Error fetching multi-preview');\n\n    // Create fake headers for 7-day expiry\n    const headers = {\n      'cache-control': 'max-age=604800',\n      expires: new Date(Date.now() + 604800000).toUTCString(),\n    };\n\n    // Read blob\n    const reader = res.body.getReader();\n\n    // 512KB buffer for reading data into\n    let buffer = new Uint8Array(512 * 1024);\n    let bufSize = 0;\n\n    // Parameters of the image we're currently reading\n    let params: {\n      reqid: number;\n      len: number;\n      type: string;\n    } | null = null;\n\n    // Index at which we are currently reading\n    let idx = 0;\n\n    while (true) {\n      // Read data from the response\n      const { value, done } = await reader.read();\n      if (done) break; // End of stream\n\n      // Check in case 1/3 the buffer is full then reset it\n      if (idx > buffer.length / 3) {\n        buffer.set(buffer.slice(idx));\n        bufSize -= idx;\n        idx = 0;\n      }\n\n      // Double the length of the buffer until it fits\n      // Hopefully this never happens\n      while (bufSize + value.length > buffer.length) {\n        const newBuffer = new Uint8Array(buffer.length * 2);\n        newBuffer.set(buffer);\n        buffer = newBuffer;\n        console.warn('Doubling multipreview buffer size', buffer.length);\n      }\n\n      // Copy data into buffer\n      buffer.set(value, bufSize);\n      bufSize += value.length;\n\n      // Process the buffer until we exhaust it or need more data\n      while (true) {\n        if (!params) {\n          // Read the length of the JSON as a single byte\n          if (bufSize - idx < 1) break;\n          const jsonLen = buffer[idx];\n          const jsonStart = idx + 1;\n\n          // Read the JSON\n          if (bufSize - jsonStart < jsonLen) break;\n          const jsonB = buffer.slice(jsonStart, jsonStart + jsonLen);\n          const jsonT = new TextDecoder().decode(jsonB);\n          idx = jsonStart + jsonLen;\n          params = JSON.parse(jsonT);\n          params = params!;\n        }\n\n        // Read the image data\n        if (bufSize - idx < params!.len) break;\n        const imgBlob = new Blob([buffer.slice(idx, idx + params!.len)], {\n          type: params!.type,\n        });\n        idx += params!.len;\n\n        // Initiate callbacks\n        for (const p of fetchPreviewQueueCopy) {\n          if (p.reqid === params.reqid && !p.done) {\n            try {\n              const dummy = getResponse(imgBlob, params!.type, headers);\n              await resolve(p.origUrl, dummy, imgBlob);\n              p.done = true;\n            } catch (e) {\n              // In case of error, we want to try fetching the single\n              // image instead, so we don't reject here\n            }\n          }\n        }\n\n        // Reset for next iteration\n        params = null;\n      }\n    }\n  } catch (e) {\n    console.error('Multipreview error', e);\n  }\n\n  // Initiate callbacks for failed requests\n  fetchPreviewQueueCopy.filter((p) => !p.done).forEach(fetchOneSafe);\n}\n\n/** Accepts a URL and returns a promise with a blob */\nasync function fetchImage(url: string): Promise<Blob> {\n  // Check if in cache\n  const cache = await imageCache?.match(url);\n  if (cache) return await cache.blob();\n\n  // Just fetch if not a preview\n  const regex = /\\/memories\\/api\\/image\\/preview\\/\\d+(\\?.*)?$/;\n  if (!regex.test(url)) {\n    const res = await fetchOneImage(url);\n    cacheResponse(url, res);\n    return await res.blob();\n  }\n\n  // Get file id from URL\n  const urlObj = new URL(url, self.location.origin);\n  const fileid = Number(urlObj.pathname.split('/').pop());\n\n  return await new Promise((resolve, reject) => {\n    if (pendingUrls.has(url)) {\n      // Already in queue, just add callback\n      pendingUrls.get(url)?.push({ resolve, reject });\n    } else {\n      // Add to queue\n      fetchPreviewQueue.push({\n        origUrl: url,\n        url: urlObj,\n        fileid,\n        reqid: Math.round(Math.random() * 1e8),\n      });\n\n      // Add to pending\n      pendingUrls.set(url, [{ resolve, reject }]);\n\n      // Start timer for flushing queue\n      if (!fetchPreviewTimer) {\n        fetchPreviewTimer = self.setTimeout(flushPreviewQueue, 20);\n      }\n\n      // If queue has >20 items, flush immediately\n      // This will internally clear the timer\n      if (fetchPreviewQueue.length >= 20) {\n        flushPreviewQueue();\n      }\n    }\n  });\n}\n\nfunction cacheResponse(url: string, res: Response) {\n  try {\n    // Skip if no-cache is present\n    if (res.headers.get('cache-control')?.toLowerCase().includes('no-cache')) return;\n\n    // Cache valid responses\n    if (res.status === 200) {\n      imageCache?.put(url, res.clone());\n      expirationManager.updateTimestamp(url.toString());\n    }\n\n    // Run expiration once in every 100 requests\n    if (Math.random() < 0.01) {\n      expirationManager.expireEntries();\n    }\n  } catch (e) {\n    console.error('Error caching response', e);\n  }\n}\n\n/** Creates a dummy response from a blob and headers */\nfunction getResponse(blob: Blob, type: string | null, headers: any = {}) {\n  return new Response(blob, {\n    status: 200,\n    headers: {\n      'Content-Type': type || headers['content-type'],\n      'Content-Length': blob.size.toString(),\n      'Cache-Control': headers['cache-control'],\n      Expires: headers.expires,\n    },\n  });\n}\n\n/** Fetch single image with axios */\nasync function fetchOneImage(url: string) {\n  const res = await fetch(url);\n  if (res.status !== 200 || !res.body) {\n    const text = res.body ? await res.text() : 'unknown';\n    throw new Error(`Error fetching single preview: ${text}`);\n  }\n  return res;\n}\n\n/** Fetch multipreview with axios */\nasync function fetchMultipreview(files: any[]) {\n  return await fetch(config.multiUrl, {\n    method: 'POST',\n    body: JSON.stringify({ files }),\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n\n/** Will be configured after the worker starts */\nlet config: { multiUrl: string };\nfunction configure(_config: typeof config) {\n  config = _config;\n}\n\n/** Get BLOB url for image */\nasync function fetchImageSrc(url: string) {\n  return URL.createObjectURL(await fetchImage(url));\n}\n\n// Exports to main thread\nexport default exportWorker({ fetchImageSrc, configure });\n"],"names":["fetchPreviewQueue","pendingUrls","Map","cacheName","imageCache","self","caches","open","console","warn","expirationManager","maxAgeSeconds","maxEntries","fetchPreviewTimer","config","async","flushPreviewQueue","clearTimeout","length","fetchPreviewQueueCopy","resolve","url","res","blob","clone","get","forEach","cb","delete","cacheResponse","fetchOneSafe","p","origUrl","fetchOneImage","e","reject","files","map","fileid","x","Number","searchParams","y","a","reqid","fetch","multiUrl","method","body","JSON","stringify","headers","fetchMultipreview","status","Error","expires","Date","now","toUTCString","reader","getReader","buffer","Uint8Array","bufSize","params","idx","value","done","read","set","slice","newBuffer","jsonLen","jsonStart","jsonB","jsonT","TextDecoder","decode","parse","len","imgBlob","Blob","type","dummy","getResponse","error","filter","toLowerCase","includes","put","updateTimestamp","toString","Math","random","expireEntries","Response","size","Expires","text","fetchImageSrc","URL","createObjectURL","cache","match","test","urlObj","location","origin","pathname","split","pop","Promise","has","push","round","setTimeout","fetchImage","configure","_config"],"sourceRoot":""}